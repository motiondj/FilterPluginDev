# 필터 체이닝

*다른 언어로 읽기: [English](FilterChaining.md), [한국어](FilterChaining_KR.md)*

정교한 신호 처리를 위한 다중 필터 조합 고급 가이드

## 📍 네비게이션

- [← 이전: 커스텀 프리셋](CustomPresets_KR.md)
- [→ 다음: 마이그레이션 가이드](Migration_KR.md)

### 📖 전체 문서
- **시작하기**
  - [빠른 시작 가이드](QuickStart_KR.md)
  - [설치 가이드](Installation_KR.md)
- **사용자 가이드**
  - [사용자 매뉴얼](UserManual_KR.md)
  - [블루프린트 예제](Examples_KR.md)
  - [모범 사례](BestPractices_KR.md)
- **기술 문서**
  - [API 레퍼런스](APIReference_KR.md)
  - [성능 가이드](Performance_KR.md)
  - [문제 해결](Troubleshooting_KR.md)
- **고급 주제**
  - [커스텀 프리셋](CustomPresets_KR.md)
  - **필터 체이닝** (현재 페이지)
  - [마이그레이션 가이드](Migration_KR.md)

---

## 📋 목차

1. [필터 체이닝이란?](#필터-체이닝이란)
2. [체인 유형](#체인-유형)
3. [필터 체인 생성](#필터-체인-생성)
4. [고급 체이닝 기법](#고급-체이닝-기법)
5. [성능 고려사항](#성능-고려사항)
6. [실제 적용 사례](#실제-적용-사례)

---

## 🔗 필터 체이닝이란?

필터 체이닝은 여러 필터를 순차적 또는 병렬로 연결하여 단일 필터로는 달성할 수 없는 더욱 정교한 필터링 결과를 얻는 과정입니다.

### 왜 필터를 체이닝하나요?

**단일 필터의 한계:**
- 칼만: 훌륭한 예측, 하지만 빠른 변화에 지연 발생 가능
- 원유로: 낮은 지연, 하지만 제한적인 노이즈 제거
- 둘 다: 모든 시나리오에 고정된 특성

**체이닝의 이점:**
- ✅ 다양한 필터 유형의 장점 결합
- ✅ 개별 필터의 약점 보완
- ✅ 적응형 필터링 시스템 생성
- ✅ 복잡한 신호 특성 처리
- ✅ 특정 사용 사례에 최적 균형 달성

### 기본 개념

```
원본 신호 → 필터 1 → 필터 2 → 필터 3 → 최종 출력
```

각 필터가 이전 필터의 출력을 처리하여 다단계 정제를 가능하게 합니다.

---

## 🔧 체인 유형

### 1. 순차 체인

필터가 선형 순서로 하나씩 데이터를 처리합니다.

```blueprint
[원본 입력] → [칼만 (High)] → [원유로 (Low)] → [최종 출력]
```

**사용 사례:**
- 노이즈 제거 후 반응성 튜닝
- 거친 필터링 후 세밀한 조정
- 다단계 신호 조정

### 2. 병렬 체인

여러 필터가 동일한 입력을 동시에 처리한 후 결과를 결합합니다.

```blueprint
[원본 입력] ─┬─ [칼만 필터] ─┐
              │               ├─ [블렌드] → [출력]
              └─ [원유로 필터] ─┘
```

**사용 사례:**
- 다양한 필터링 방식 비교
- 필터 장점들의 가중 조합
- 백업 시스템

### 3. 계층적 체인

여러 레벨과 분기를 가진 복잡한 중첩 구조입니다.

```blueprint
[원본 입력] → [전처리 필터] ─┬─ [경로 A: 반응형] ─┐
                              │                   ├─ [선택기] → [출력]
                              └─ [경로 B: 부드러움] ─┘
```

**사용 사례:**
- 컨텍스트 인식 필터링
- 적응형 시스템
- 복잡한 신호 처리 파이프라인

### 4. 피드백 체인

필터가 출력 특성에 따라 체인의 이전 단계에 영향을 줄 수 있습니다.

```blueprint
[입력] → [필터 1] → [필터 2] → [출력]
          ↑                     │
          └─── [피드백 로직] ←────┘
```

**사용 사례:**
- 자체 튜닝 시스템
- 적응형 파라미터 조정
- 오류 보정 루프

---

## 🛠️ 필터 체인 생성

### 방법 1: 수동 체인 구성

개별 필터를 사용하여 단계별로 체인을 구축합니다.

#### 순차 체인 예제
```blueprint
Event BeginPlay
├─ [Create Filter] (Type: Kalman) → "Stage1"로 저장
├─ [Initialize Filter] (Stage1, Preset: High)
├─ [Create Filter] (Type: OneEuro) → "Stage2"로 저장
└─ [Initialize Filter] (Stage2, Preset: Low)

Event Tick
├─ [Update Filter] (Stage1, 원본 입력) → 중간값
└─ [Update Filter] (Stage2, 중간값) → 최종 출력
```

#### 병렬 체인 예제
```blueprint
Event BeginPlay
├─ [Create Filter] (Type: Kalman) → "PathA"로 저장
├─ [Create Filter] (Type: OneEuro) → "PathB"로 저장
├─ [Initialize Filter] (PathA, Preset: Medium)
└─ [Initialize Filter] (PathB, Preset: Medium)

Event Tick
├─ [Update Filter] (PathA, 원본 입력) → 결과A
├─ [Update Filter] (PathB, 원본 입력) → 결과B
└─ [Lerp] (결과A, 결과B, Alpha: 0.6) → 블렌드된 출력
```

### 방법 2: 체인 시스템 노드

쉬운 관리를 위해 내장 체인 시스템을 사용합니다.

#### 기본 체인 생성
```blueprint
Event BeginPlay
├─ [Create Filter Chain]
│  ├─ Chain Name: "SmoothResponsive"
│  ├─ Filters: [Kalman, OneEuro]
│  ├─ Presets: [High, Low]
│  └─ Blend Weights: [0.7, 0.3]
└─ 체인 참조 저장

Event Tick
├─ [Process Through Chain]
│  ├─ Chain: 저장된 참조
│  ├─ Input: 원본 신호
│  └─ Delta Time: Event Delta
└─ 최종 출력 얻기
```

#### 고급 체인 구성
```blueprint
[Create Advanced Chain]
├─ Chain Type: Hierarchical
├─ Stages:
│  ├─ Stage 1: 전처리
│  │  ├─ Filter: OneEuro (Very Low)
│  │  └─ Purpose: 고주파 노이즈 제거
│  ├─ Stage 2: 주 처리
│  │  ├─ Path A: Kalman (High) - 부드러운 카메라용
│  │  ├─ Path B: OneEuro (Medium) - 반응적 UI용
│  │  └─ Selector: 입력 속도 기반
│  └─ Stage 3: 후처리
│     ├─ Filter: 커스텀 프리셋
│     └─ Purpose: 최종 정제
└─ 체인 구축 완료
```

---

## 🚀 고급 체이닝 기법

### 1. 적응형 체인 선택

신호 특성에 따라 사용할 체인을 동적으로 선택합니다.

```blueprint
[입력 신호 분석]
├─ Speed: 속도 크기 계산
├─ Noise Level: 신호 분산 측정
└─ Pattern: 주기적 vs 랜덤 감지

[체인 선택]
├─ IF Speed > 임계값 AND Noise < 임계값
│  └─ "Responsive" 체인 사용 (원유로 + 가벼운 칼만)
├─ ELSE IF Speed < 임계값 AND Noise > 임계값
│  └─ "Smooth" 체인 사용 (강한 칼만 + 원유로)
└─ ELSE
   └─ "Balanced" 체인 사용 (중간 설정)
```

### 2. 체인 모핑

서로 다른 체인 구성 간의 부드러운 전환입니다.

```blueprint
[체인 모핑 시스템]
├─ Current Chain: "Configuration A"
├─ Target Chain: "Configuration B"
├─ Morph Progress: 0.0 ~ 1.0
└─ Interpolated Chain: A와 B의 블렌드

Event Tick
├─ 모핑 진행도 업데이트 (+Delta * MorphSpeed)
├─ [Interpolate Chain Parameters]
│  ├─ FilterA Weight: Lerp(WeightA1, WeightA2, Progress)
│  ├─ FilterB Weight: Lerp(WeightB1, WeightB2, Progress)
│  └─ 보간된 가중치 적용
└─ 모핑된 체인을 통해 신호 처리
```

### 3. 다중 해상도 체인

서로 다른 필터가 다른 주파수 성분을 처리합니다.

```blueprint
[다중 해상도 처리]
├─ 입력 신호
├─ 고주파 경로: 원유로 (Very Low 프리셋)
│  └─ 빠른 변화 처리
├─ 중주파 경로: 원유로 (Medium 프리셋)
│  └─ 일반적인 움직임 처리
├─ 저주파 경로: 칼만 (High 프리셋)
│  └─ 느린 트렌드 처리
└─ [주파수 결합] → 최종 출력
```

### 4. 예측형 체인

필터 예측을 사용하여 다른 필터에 영향을 줍니다.

```blueprint
[예측형 체인 시스템]
├─ [칼만 필터] → 현재 추정값 + 예측값
├─ [예측 분석기]
│  ├─ IF 예측값이 측정값과 크게 다름
│  │  └─ 원유로 반응성 증가
│  └─ ELSE
│     └─ 원유로 일반 설정 유지
└─ [원유로 필터] (적응형 설정) → 최종 출력
```

### 5. 오류 보정 체인

자체 오류를 감지하고 보정하는 체인입니다.

```blueprint
[오류 보정 체인]
├─ [주 필터] → 주 출력
├─ [보조 필터] → 보조 출력
├─ [오류 감지]
│  ├─ 주 vs 보조 비교
│  ├─ 출력 vs 원본 입력 비교
│  └─ 이상 또는 발산 감지
├─ [오류 보정]
│  ├─ IF 오류 감지됨
│  │  ├─ 일시적으로 반응성 증가
│  │  ├─ 필요시 필터 상태 리셋
│  │  └─ 보조 필터를 주 필터로 사용
│  └─ ELSE 정상 동작 유지
└─ [보정된 출력]
```

---

## ⚡ 성능 고려사항

### 체인 오버헤드

체인의 각 필터가 계산 비용을 추가합니다:

| 체인 길이 | CPU 영향 | 메모리 영향 | 지연 영향 |
|-----------|----------|-------------|----------|
| 1 필터 | 1x | 1x | 1x |
| 2 필터 | 1.8x | 2x | 1.2x |
| 3 필터 | 2.5x | 3x | 1.5x |
| 4+ 필터 | 3x+ | 4x+ | 2x+ |

### 최적화 전략

#### 1. 조건부 처리
```blueprint
// 불필요할 때 비싼 필터 건너뛰기
[신호 분석]
├─ IF 신호가 안정적 (낮은 분산)
│  └─ 비싼 스무딩 필터 건너뛰기
├─ ELSE IF 신호가 매우 노이즈가 많음
│  └─ 모든 노이즈 제거 단계 활성화
└─ ELSE 표준 체인 사용
```

#### 2. 프레임 레이트 스케일링
```blueprint
// 성능에 따라 체인 복잡도 조정
[성능 모니터]
├─ IF 프레임 레이트 > 60 FPS
│  └─ 전체 체인 활성화 (모든 필터)
├─ ELSE IF 프레임 레이트 > 30 FPS
│  └─ 축소 체인 활성화 (2개 필터)
└─ ELSE 최소 체인 활성화 (1개 필터)
```

#### 3. LOD 기반 체인
```blueprint
// 거리 기반 체인 복잡도
[거리 기반 체인]
├─ 거리 < 10m: 전체 4단계 체인
├─ 거리 < 50m: 2단계 체인
├─ 거리 < 100m: 단일 필터
└─ 거리 > 100m: 필터링 없음
```

#### 4. 배치 체인 처리
```blueprint
// 같은 체인을 통해 여러 신호 처리
[배치 체인 처리]
├─ Input: 신호 배열
├─ 모두 Stage 1 처리
├─ 모두 Stage 2 처리
├─ 모두 Stage 3 처리
└─ Output: 필터링된 결과 배열
```

---

## 🎮 실제 적용 사례

### 적용 사례 1: 전문 카메라 시스템

영화 제작을 위한 다단계 카메라 안정화입니다.

```blueprint
[전문 카메라 체인]
├─ Stage 1: 떨림 제거
│  ├─ Filter: 원유로 (Very Low 프리셋)
│  └─ Purpose: 고주파 카메라 흔들림 제거
├─ Stage 2: 모션 스무딩
│  ├─ Filter: 칼만 (커스텀: Q=0.001, R=0.5)
│  └─ Purpose: 카메라 움직임 부드럽게
├─ Stage 3: 드리프트 보정
│  ├─ Filter: 원유로 (커스텀: 매우 낮은 Beta)
│  └─ Purpose: 느린 드리프트 방지
└─ Stage 4: 최종 마무리
   ├─ Filter: 가벼운 칼만 (Q=0.01, R=0.1)
   └─ Purpose: 미세 조정
```

**결과:**
- 98% 노이즈 감소
- 시네마 품질 부드러움
- 2-3 프레임 지연 (녹화용 허용 범위)

### 적용 사례 2: VR 손 추적 시스템

편안함과 정밀도의 균형을 맞춘 적응형 손 추적입니다.

```blueprint
[VR 손 추적 체인]
├─ 활동별 분기
│  ├─ 세밀한 동작 (그리기, 타이핑):
│  │  ├─ Stage 1: 원유로 (Ultra Low 프리셋)
│  │  └─ Stage 2: 안정성을 위한 가벼운 칼만
│  └─ 거친 동작 (제스처, 포인팅):
│     ├─ Stage 1: 원유로 (Low 프리셋)
│     └─ Stage 2: 부드러움을 위한 중간 칼만
├─ 편안함 레이어:
│  ├─ 멀미 지표 모니터링
│  ├─ IF 사용자가 불편함 표시
│  │  └─ 필터링 감소, 반응성 증가
│  └─ ELSE 품질 필터링 유지
└─ 최종 출력: 편안함 + 정밀도 균형
```

### 적용 사례 3: 모바일 게임 입력 시스템

다양한 게임 장르를 위한 터치 입력 처리입니다.

```blueprint
[모바일 게임 입력 체인]
├─ 장르 감지:
│  ├─ 레이싱 게임:
│  │  ├─ 조향용 원유로 (Low)
│  │  └─ 칼만 없음 (지연 중요)
│  ├─ 전략 게임:
│  │  ├─ 부드러운 카메라용 칼만 (High)
│  │  └─ 유닛 선택용 원유로 (Medium)
│  └─ 퍼즐 게임:
│     ├─ 부드러운 상호작용용 칼만 (High)
│     └─ 정밀한 배치용 원유로 (High)
├─ 기기 적응:
│  ├─ 고사양 기기: 전체 체인
│  ├─ 중사양 기기: 축소 체인
│  └─ 저사양 기기: 단일 필터
└─ 배터리 최적화:
   ├─ IF 배터리 < 20%
   │  └─ 체인 복잡도 감소
   └─ ELSE 품질 유지
```

### 적용 사례 4: 산업용 센서 처리

오류 감지를 통한 다중 센서 데이터 융합입니다.

```blueprint
[산업용 센서 체인]
├─ 센서 검증:
│  ├─ 센서 상태 확인
│  ├─ 잘못된 읽기 감지
│  └─ 신뢰할 수 없는 센서 표시
├─ 다중 센서 융합:
│  ├─ 주 센서: 강한 칼만 필터링
│  ├─ 보조 센서: 중간 필터링
│  ├─ 3차 센서: 가벼운 필터링
│  └─ 신뢰도 기반 가중 조합
├─ 이상 감지:
│  ├─ 융합 결과와 개별 센서 비교
│  ├─ IF 이상 감지됨
│  │  ├─ 신뢰할 수 없는 센서의 필터링 증가
│  │  └─ 유지보수 시스템 경고
│  └─ ELSE 정상 동작 계속
└─ 안전 한계:
   ├─ 출력이 안전 범위 내 유지 보장
   └─ 한계 초과 시 비상 정지
```

### 적용 사례 5: 오디오-비주얼 동기화

실시간으로 오디오에 맞춰 시각 효과를 동기화합니다.

```blueprint
[오디오-비주얼 동기화 체인]
├─ 오디오 분석:
│  ├─ 비트 감지: 원유로 (Ultra Low)
│  ├─ 주파수 분석: 칼만 (Medium)
│  └─ 볼륨 엔벨로프: 원유로 (Low)
├─ 시각적 반응:
│  ├─ 빠른 효과 (조명): 원유로에서 직접
│  ├─ 중간 효과 (파티클): 균형 체인에서
│  └─ 느린 효과 (카메라): 칼만 체인에서
├─ 동기화:
│  ├─ 처리 지연 보상
│  ├─ 오디오 변화 예측
│  └─ 시각적 타이밍 적절히 조정
└─ 최종 출력: 동기화된 오디오-비주얼 경험
```

---

## 🔧 체인 디버깅 및 모니터링

### 실시간 체인 시각화

체인 성능과 동작을 모니터링합니다:

```blueprint
[체인 디버그 시스템]
├─ [체인 흐름 시각화]
│  ├─ 입력 신호 표시 (빨간색)
│  ├─ 중간 단계 표시 (노란색)
│  └─ 최종 출력 표시 (녹색)
├─ [성능 모니터링]
│  ├─ 단계별 CPU 사용량
│  ├─ 메모리 할당
│  └─ 처리 지연 시간
└─ [품질 지표]
   ├─ 노이즈 감소 비율
   ├─ 신호 지연 측정
   └─ 안정성 지표
```

### 체인 최적화 도구

```blueprint
[체인 최적화기]
├─ [신호 특성 분석]
│  ├─ 주파수 내용
│  ├─ 노이즈 패턴
│  └─ 움직임 패턴
├─ [최적 체인 제안]
│  ├─ 필터 유형 추천
│  ├─ 프리셋 제안
│  └─ 체인 구조 제안
└─ [체인 A/B 테스트]
   ├─ 다른 구성 비교
   ├─ 객관적 품질 지표 측정
   └─ 사용자 선호도 테스트
```

---

## 📚 체인 설계 패턴

### 패턴 1: 노이즈 감소 → 반응성
```blueprint
// 신호를 정리한 후 반응적으로 만들기
[높은 노이즈 입력] → [강한 칼만] → [가벼운 원유로] → [깨끗하고 반응적]
```

### 패턴 2: 반응성 → 안정성
```blueprint
// 빠른 반응 후 안정화
[떨리는 입력] → [원유로 Low] → [칼만 Medium] → [반응적이고 안정적]
```

### 패턴 3: 병렬 처리 → 선택
```blueprint
// 여러 접근법, 최선 선택
[입력] ─┬─ [부드러운 경로] ──┐
        ├─ [빠른 경로] ────┼─ [선택기] → [출력]
        └─ [균형 경로] ─────┘
```

### 패턴 4: 계단식 정제
```blueprint
// 점진적 정제
[원본] → [거친 필터] → [중간 필터] → [세밀한 필터] → [마무리]
```

### 패턴 5: 피드백 제어
```blueprint
// 자체 조정 시스템
[입력] → [적응형 필터] → [출력]
          ↑                │
          └─ [피드백] ←─────┘
```

---

## 📝 모범 사례

### 해야 할 것 ✅
1. **간단하게 시작**: 복잡해지기 전에 2필터 체인으로 시작
2. **성능 모니터링**: 항상 체인 성능 프로파일
3. **적절한 유형 사용**: 필터 유형을 장점에 맞게 활용
4. **철저한 테스트**: 실제 데이터로 체인 검증
5. **체인 문서화**: 각 필터가 필요한 이유 설명

### 하지 말아야 할 것 ❌
1. **과도한 체이닝 금지**: 필터가 많다고 결과가 좋아지는 것은 아님
2. **지연 무시 금지**: 각 단계가 지연을 추가
3. **컨텍스트 망각 금지**: 체인은 사용 사례와 일치해야 함
4. **최적화 건너뛰기 금지**: 사용하지 않는 체인은 자원 낭비
5. **무작위 체이닝 금지**: 각 필터는 목적이 있어야 함

---

## 🎯 빠른 참조

### 일반적인 체인 패턴

| 사용 사례 | 패턴 | 필터 |
|-----------|------|------|
| **게임 입력** | 빠름→마무리 | 원유로 Low → 칼만 Low |
| **카메라 부드럽게** | 정리→안정화 | 칼만 High → 원유로 Medium |
| **VR 편안함** | 균형 | 원유로 Low + 칼만 Medium (블렌드) |
| **센서 융합** | 검증→필터 | 다중 칼만 → 가중 평균 |
| **오디오 동기화** | 다중 속도 | 원유로 Ultra + 칼만 Medium (병렬) |

### 성능 가이드라인

- **2개 필터**: 대부분의 사용 사례에 이상적
- **3개 필터**: 복잡한 시나리오에 사용
- **4개 이상 필터**: 특수 애플리케이션에만
- **병렬 체인**: 최대 2-3개 분기
- **업데이트 속도**: 먼 객체는 감소 고려

---

정교한 필터링 시스템을 만들 준비가 되었습니다! 🔗

버전 마이그레이션 가이드는 [마이그레이션 가이드](Migration_KR.md)를 참조하세요 →